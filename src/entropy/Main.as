package entropy {
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import org.flintparticles.twoD.actions.CollisionZone;
	import org.flintparticles.twoD.renderers.BitmapRenderer;
	import org.flintparticles.twoD.zones.BitmapDataZone;
	import org.flintparticles.twoD.zones.DiscZone;
	import org.flintparticles.twoD.zones.LineZone;
	import org.flintparticles.twoD.zones.MultiZone;
	
	import flash.net.registerClassAlias;
	
	[Frame(factoryClass="entropy.Preloader")]
	public class Main extends Sprite {
		/**
		 * The default stage width, and the value that should be used as
		 * the stage width even when the window scales.
		 */
		public static const STAGE_WIDTH:int = 640;
		
		/**
		 * See STAGE_WIDTH.
		 */
		public static const STAGE_HEIGHT:int = 480;
		
		/**
		 * The renderer manages and renders the particle system.
		 */
		private var renderer:BitmapRenderer;
		
		/**
		 * Currently the only emitter, because using multiple emitters
		 * would require registering the same collision data with each
		 * emitter.
		 */
		private var emitter:GasEmitter;
		
		/**
		 * A "container" display object is intended to hold multiple objects
		 * of the same type, so that they all get drawn as a group.
		 */
		private var wallContainer:Sprite;
		
		public function Main() {
			//autogenerated
			//call init() once this has a reference to the stage
			if(stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);
		}
		
		private function init(e:Event = null):void {
			//also autogenerated; the "entry point" is directly after this line
			removeEventListener(Event.ADDED_TO_STAGE, init);
			
			//draw a black rectangle behind the stage
			graphics.beginFill(0x000000);
			graphics.drawRect(0, 0, STAGE_WIDTH, STAGE_HEIGHT);
			graphics.endFill();
			
			wallContainer = new Sprite();
			
			emitter = new GasEmitter();
			renderer = new BitmapRenderer(new Rectangle(0, 0, STAGE_WIDTH, STAGE_HEIGHT));
			renderer.addEmitter(emitter);
			
			//add children in the order they should be drawn
			addChild(renderer);
			addChild(wallContainer);
			
			//add a few hexagons at various points
			addWall(480, 240);
			addWall(612, 413);
			addWall(300, 20);
			addWall(240, 360);
			
			//emit a bunch of particles within a hexagonal region
			emitter.emitFrom(600, new HexagonZone(STAGE_WIDTH / 2, STAGE_HEIGHT / 2, 100));
		}
		
		/**
		 * Adds the collision data and image for a hexagonal wall segment,
		 * centered at the given point.
		 */
		private function addWall(x:Number, y:Number):void {
			var tile:HexTile = new HexTile(HexTile.FILLED, x, y);
			wallContainer.addChild(tile);
			if(tile.getCollisionZone() != null) {
				emitter.addAction(new CollisionZone(tile.getCollisionZone()));
			}
		}
	}
}